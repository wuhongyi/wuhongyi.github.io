<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ROOT Histograms | Hongyi Wu(吴鸿毅)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一些基本说明ROOT 版本越高，其函数功能越多。随版本提升，不断修复以前版本的 bug，又增加了新功能。但是从 ROOT 6.03 开始，就要求 Python 版本大于 2.7（LLVM/Clang要求） ，但是在 Scientific Linux 6 下， 直接对系统的 Python 升级版本会造成桌面显示的问题，因为 Python 在版本提升中一些标准更改造成不兼容。一个好的方法就是在 /us">
<meta property="og:type" content="article">
<meta property="og:title" content="ROOT Histograms">
<meta property="og:url" content="http://wuhongyi.github.io/2015/06/07/ROOTHistograms/index.html">
<meta property="og:site_name" content="Hongyi Wu(吴鸿毅)">
<meta property="og:description" content="一些基本说明ROOT 版本越高，其函数功能越多。随版本提升，不断修复以前版本的 bug，又增加了新功能。但是从 ROOT 6.03 开始，就要求 Python 版本大于 2.7（LLVM/Clang要求） ，但是在 Scientific Linux 6 下， 直接对系统的 Python 升级版本会造成桌面显示的问题，因为 Python 在版本提升中一些标准更改造成不兼容。一个好的方法就是在 /us">
<meta property="og:updated_time" content="2015-10-06T11:14:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ROOT Histograms">
<meta name="twitter:description" content="一些基本说明ROOT 版本越高，其函数功能越多。随版本提升，不断修复以前版本的 bug，又增加了新功能。但是从 ROOT 6.03 开始，就要求 Python 版本大于 2.7（LLVM/Clang要求） ，但是在 Scientific Linux 6 下， 直接对系统的 Python 升级版本会造成桌面显示的问题，因为 Python 在版本提升中一些标准更改造成不兼容。一个好的方法就是在 /us">
  
    <link rel="alternative" href="/atom.xml" title="Hongyi Wu(吴鸿毅)" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/why.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Hongyi Wu(吴鸿毅)</a></h1>
		</hgroup>

		
		<p class="header-subtitle">坚持引进、消化、吸收……</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Link</li>
						
						
						<li>AboutMe</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
							<li><a href="/tags/Linux">Linux</a></li>
				        
							<li><a href="/tags/Nuclearphysics">Nuclearphysics</a></li>
				        
							<li><a href="/about">AboutMe</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/wuhongyi" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/wuhongyi" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/GCC/" style="font-size: 10px;">GCC</a> <a href="/tags/GDB/" style="font-size: 10px;">GDB</a> <a href="/tags/Geant4/" style="font-size: 10px;">Geant4</a> <a href="/tags/Geant4-ROOT/" style="font-size: 12.5px;">Geant4-ROOT</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Latex/" style="font-size: 10px;">Latex</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/Nuclearphysics/" style="font-size: 10px;">Nuclearphysics</a> <a href="/tags/Octopress/" style="font-size: 10px;">Octopress</a> <a href="/tags/PATH/" style="font-size: 10px;">PATH</a> <a href="/tags/QStarDict/" style="font-size: 10px;">QStarDict</a> <a href="/tags/RTFM/" style="font-size: 10px;">RTFM</a> <a href="/tags/Software/" style="font-size: 17.5px;">Software</a> <a href="/tags/TEST/" style="font-size: 10px;">TEST</a> <a href="/tags/TH1/" style="font-size: 10px;">TH1</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/tags/cryptsetup/" style="font-size: 10px;">cryptsetup</a> <a href="/tags/essay/" style="font-size: 12.5px;">essay</a> <a href="/tags/rand/" style="font-size: 10px;">rand</a> <a href="/tags/rar/" style="font-size: 10px;">rar</a> <a href="/tags/shell/" style="font-size: 12.5px;">shell</a> <a href="/tags/string/" style="font-size: 10px;">string</a> <a href="/tags/texlive/" style="font-size: 10px;">texlive</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/wiznote/" style="font-size: 10px;">wiznote</a> <a href="/tags/xerces/" style="font-size: 10px;">xerces</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://http://www.pku.edu.cn/">PekingUniversity</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://geant4.cern.ch/">Geant4</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://root.cern.ch/drupal/">ROOT</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cplusplus.com/">C++</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">人民，只有人民，才是创造世界历史的动力！</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Hongyi Wu(吴鸿毅)</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="img/why.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Hongyi Wu(吴鸿毅)</h1>
			</hgroup>
			
			<p class="header-subtitle">坚持引进、消化、吸收……</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
					<li><a href="/tags/Linux">Linux</a></li>
		        
					<li><a href="/tags/Nuclearphysics">Nuclearphysics</a></li>
		        
					<li><a href="/about">AboutMe</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wuhongyi" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/wuhongyi" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-ROOTHistograms" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/07/ROOTHistograms/" class="article-date">
  	<time datetime="2015-06-07T02:16:59.000Z" itemprop="datePublished">2015-06-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ROOT Histograms
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Geant4-ROOT/">Geant4-ROOT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Software/">Software</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TH1/">TH1</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一些基本说明">一些基本说明</h1><p>ROOT 版本越高，其函数功能越多。随版本提升，不断修复以前版本的 bug，又增加了新功能。但是从 ROOT 6.03 开始，就要求 Python 版本大于 2.7（LLVM/Clang要求） ，但是在 Scientific Linux 6 下， 直接对系统的 Python 升级版本会造成桌面显示的问题，因为 Python 在版本提升中一些标准更改造成不兼容。一个好的方法就是在 /usr/local 下安装高版本的 Python，然后安装 ROOT 的时候给指定该 Python 的路径，还有一个偷懒的办法是直接更改 configure 文件中 Phyhon 版本的要求和 interpreter/llvm/src/configure 文件中 Python 版本的要求，这个会不会造成什么影响不清楚。<a id="more"></a></p>
<p>ROOT6 要求 gcc 版本大于 4.7，经过一年多的使用验证 gcc4.9.2 版本是可靠的。gcc5的版本暂时不要使用。这里我就选择 6.02/10 为基准来介绍 ROOT 的一些使用。</p>
<h1 id="Histograms">Histograms</h1><h2 id="TH1">TH1</h2><h3 id="TH1(const_char_*name,const_char_*title,Int_t_nbinsx,Double_t_xlow,Double_t_xup);">TH1(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup);</h3><p>这里 name 是该直方图的变量名字，这个名字命名最好符合 C/C++ 变量的规范，因为在将其保存成 ROOT 文件时候，该名字就是用来操作这个直方图的指针名，title 是用来描述该直方图的，nbinsx 是该直方图要分的分数，xlow 是该直方图的下限，xup 是该直方图的上限。</p>
<figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,<span class="number">100</span>,<span class="number">0.0</span>,<span class="number">10.0</span>);</span><br><span class="line">TH1D *hh=<span class="keyword">new</span> TH1D(<span class="string">"h1"</span>,<span class="string">""</span>,<span class="number">20</span>,-<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Bool_t_Add(const_TH1_*h1,_Double_t_c1=1);">Bool_t   Add(const TH1 *h1, Double_t c1=1);</h3><p>该函数是将h1直方图进行c1倍的放大或缩小后加到当前直方图中。</p>
<figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TH1D *h1=<span class="keyword">new</span> TH1D(<span class="string">"h1"</span>,<span class="string">""</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r=<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  h-&gt;Fill(r-&gt;Uniform());</span><br><span class="line">  h1-&gt;Fill(r-&gt;Uniform(<span class="number">1.5</span>,<span class="number">2.5</span>)); </span><br><span class="line">&#125;</span><br><span class="line">h-&gt;Add(h1,<span class="number">2</span>);</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure>
<h3 id="Bool_t_Add(const_TH1_*h1,_const_TH1_*h2,_Double_t_c1=1,_Double_t_c2=1);">Bool_t   Add(const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1);</h3><p>Replace contents of this histogram by the addition of h1 and h2.<br>将 h1 放大或缩小 c1 倍加上 h2 放大或缩小 c2 倍相加赋给 h。</p>
<figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TH1D *h1=<span class="keyword">new</span> TH1D(<span class="string">"h1"</span>,<span class="string">""</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TH1D *h2=<span class="keyword">new</span> TH1D(<span class="string">"h1"</span>,<span class="string">""</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r=<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// h-&gt;Fill(r-&gt;Uniform());</span></span><br><span class="line">  h1-&gt;Fill(r-&gt;Uniform(<span class="number">1.5</span>,<span class="number">2.5</span>)); </span><br><span class="line">  h2-&gt;Fill(r-&gt;Uniform(-<span class="number">2.5</span>,-<span class="number">1.5</span>)); </span><br><span class="line">&#125;</span><br><span class="line">h-&gt;Add(h1,h2,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure>
<h3 id="void_AddBinContent(Int_t_bin);">void   AddBinContent(Int_t bin);</h3><p>在第 bin 个 bin 上计数加一。</p>
<figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  h-&gt;AddBinContent(<span class="number">10</span>);</span><br><span class="line">  h-&gt;AddBinContent(<span class="number">20</span>);</span><br><span class="line">  h-&gt;AddBinContent(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure>
<h3 id="TObject*_Clone(const_char*_newname=0)_const;">TObject*   Clone(const char* newname=0) const;</h3><p>克隆直方图，这里的 Close 是新开辟一块内存空间存储新直方图的，克隆之后，原始直方图的修改或删除对克隆的直方图没有影响。而TH1D *hnew =h;这个只是将新建的对象指向 h 的地址。<br><figure class="highlight lisp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TH1D *h=new TH1D<span class="list">(<span class="string">"h"</span>,<span class="string">"the title"</span>,<span class="number">60</span>,<span class="number">-3.0</span>,<span class="number">3.0</span>)</span><span class="comment">;</span></span><br><span class="line">TRandom *r =new TRandom<span class="list">()</span><span class="comment">;</span></span><br><span class="line">for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i&lt;1000; ++i)</span></span><br><span class="line">&#123;</span><br><span class="line">  h-&gt;Fill<span class="list">(<span class="keyword">r-&gt;Gaus</span><span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">TH1D <span class="variable">*hnew = (TH1D*</span>)</span>h-&gt;Clone<span class="list">(<span class="string">"hnew"</span>)</span><span class="comment">;</span></span><br><span class="line">// TH1D *hnew =h<span class="comment">;</span></span><br><span class="line">h-&gt;Reset<span class="list">()</span><span class="comment">;</span></span><br><span class="line">hnew-&gt;Draw<span class="list">()</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="void_Draw(Option_t_*option=””);">void   Draw(Option_t *option=””);</h3><p>默认情况下，Draw 将会清空当 前Pad 再画当前直方图，如想要一个图上多个直方图，将第二个及之后的直方图 Option_t 设为 “same”。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TH1D *h1=<span class="keyword">new</span> TH1D(<span class="string">"h1"</span>,<span class="string">""</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  h1-&gt;Fill(r-&gt;Gaus(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;Draw();</span><br><span class="line"><span class="comment">// h1-&gt;Draw();</span></span><br><span class="line">h1-&gt;Draw(<span class="string">"same"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="Int_t_Fill(Double_t_x);">Int_t   Fill(Double_t x);</h3><p>将 $x$ 填充入直方图。</p>
<h3 id="Int_t_Fill(Double_t_x,_Double_t_w);">Int_t   Fill(Double_t x, Double_t w);</h3><p>将 $x$ 填充入直方图，其中 $w$ 为权值。</p>
<h3 id="void_FillN(Int_t_ntimes,_const_Double_t_*x,_const_Double_t_*w,_Int_t_stride=1);">void   FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);</h3><h3 id="Int_t_FindBin(Double_t_x,_Double_t_y=0,_Double_t_z=0);">Int_t   FindBin(Double_t x, Double_t y=0, Double_t z=0);</h3><p>对一维直方图，返回 x 值所在 bin，若为二维直方图，返回 （x，y） 所在 bin，三维同理。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,<span class="number">60</span>,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;FindBin(<span class="number">1.0</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_*GetIntegral();">Double_t   *GetIntegral();</h3><p>Return a pointer to the array of bins integral.<br>返回一个指向数组的指针，当前值为 bin 从 0到当前 bin 面积所占的比例。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">double</span> *Integral;</span><br><span class="line">Integral=h-&gt;GetIntegral();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;bin; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;Integral[i]&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">  &#125;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Int_t_GetBin(Int_t_binx,_Int_t_biny=0,_Int_t_binz=0)_const;">Int_t   GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) const;</h3><p>Return Global bin number corresponding to binx,y,z.  2-D and 3-D histograms are represented with a one dimensional structure. This has the advantage that all existing functions, such as  GetBinContent, GetBinError, GetBinFunction work for all dimensions.</p>
<p>对一维直方图其没有作用，将二维、三维 bin 的编号方式转为一维的 bin 编号方式。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBin(<span class="number">41</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">20</span>;</span><br><span class="line">TH2D *h =<span class="keyword">new</span> TH2D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">1.0</span>,<span class="number">1.0</span>,bin,-<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus(),r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBin(<span class="number">0</span>,<span class="number">0</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBin(<span class="number">0</span>,<span class="number">1</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBin(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure>
<h3 id="void_GetBinXYZ(Int_t_binglobal,_Int_t_\&amp;binx,_Int_t_\&amp;biny,_Int_t_\&amp;binz)_const;">void   GetBinXYZ(Int_t binglobal, Int_t \&amp;binx, Int_t \&amp;biny, Int_t \&amp;binz) const;</h3><p>这个在三维直方图中使用。</p>
<h3 id="Double_t_GetBinCenter(Int_t_bin)_const;">Double_t   GetBinCenter(Int_t bin) const;</h3><p>返回该bin的中点坐标。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinCenter(<span class="number">30</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinCenter(<span class="number">31</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetBinContent(Int_t_bin)_const;">Double_t   GetBinContent(Int_t bin) const;</h3><p>返回该bin的计数。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinContent(<span class="number">12</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinContent(<span class="number">31</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetBinContent(Int_t_bin,_Int_t)_const;">Double_t   GetBinContent(Int_t bin, Int_t) const;</h3><p>二维直方图返回该bin的计数。</p>
<h3 id="Double_t_GetBinContent(Int_t_bin,_Int_t,_Int_t)_const;">Double_t   GetBinContent(Int_t bin, Int_t, Int_t) const;</h3><p>三维直方图返回该bin的计数。</p>
<h3 id="Double_t_GetBinError(Int_t_bin)_const;">Double_t   GetBinError(Int_t bin) const;</h3><p>Return value of error associated to bin number bin. if the sum of squares of weights has been defined (via Sumw2),this function returns the sqrt(sum of w2). otherwise it returns the sqrt(contents) for this bin.<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinError(<span class="number">12</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinError(<span class="number">31</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetBinError(Int_t_binx,_Int_t_biny)_const;">Double_t   GetBinError(Int_t binx, Int_t biny) const;</h3><p>for 2D histograms only</p>
<p>同一维一样。</p>
<h3 id="Double_t_GetBinError(Int_t_binx,_Int_t_biny,_Int_t_binz)_const;">Double_t   GetBinError(Int_t binx, Int_t biny, Int_t binz) const;</h3><p>for 3D histograms only</p>
<p>同一维一样。</p>
<h3 id="Double_t_GetBinErrorLow(Int_t_bin)_const;">Double_t   GetBinErrorLow(Int_t bin) const;</h3><p>Return lower error associated to bin number bin. The error will depend on the statistic option used will return the binContent - lower interval value</p>
<h3 id="Double_t_GetBinErrorUp(Int_t_bin)_const;">Double_t   GetBinErrorUp(Int_t bin) const;</h3><p>Return upper error associated to bin number bin. The error will depend on the statistic option used will return the binContent - upper interval value</p>
<h3 id="Double_t_GetBinLowEdge(Int_t_bin)_const;">Double_t   GetBinLowEdge(Int_t bin) const;</h3><p>return bin lower edge for 1D historam<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinLowEdge(<span class="number">12</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinLowEdge(<span class="number">31</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetBinWidth(Int_t_bin)_const;">Double_t   GetBinWidth(Int_t bin) const;</h3><p>返回bin的宽度。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinWidth(<span class="number">10</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetBinWidth(<span class="number">31</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetEntries()_const;">Double_t   GetEntries() const;</h3><p> returns the number of entries<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetEntries()&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetKurtosis(Int_t_axis=1)_const;">Double_t GetKurtosis(Int_t axis=1) const;</h3><p>For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.Kurtosis(gaussian(0, 1)) = 0.</p>
<p>For axis =11, 12 or 13 returns the approximate standard error of kurtosis of the histogram along x, y or z axis. Note, that since third and fourth moment are not calculated at the fill time, kurtosis and its standard error are computed bin by bin<br><figure class="highlight"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetMean(Int_t_axis=1)_const;">Double_t   GetMean(Int_t axis=1) const;</h3><p>returns the mean value along axis. For axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis. For axis = 11, 12, 13 returns the standard error of the mean value of the histogram along X, Y or Z axis.</p>
<p>Note that the mean value/RMS is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetMean(<span class="number">1</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetMeanError(Int_t_axis=1)_const;">Double_t   GetMeanError(Int_t axis=1) const;</h3><p>Return standard error of mean of this histogram along the X axis.</p>
<p>Note that the mean value/RMS is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes  all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram. </p>
<p> Also note, that although the definition of standard error doesn’t include the assumption of normality, many uses of this feature implicitly assume it.<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetMeanError(<span class="number">1</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Int_t_GetNbinsX()_const;">Int_t   GetNbinsX() const;</h3><p>获取该轴bin数。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus(),<span class="number">0.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetNbinsX()&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Int_t_GetNbinsY()_const;">Int_t   GetNbinsY() const;</h3><p>获取该轴bin数，在二维或三维直方图中使用。</p>
<h3 id="Int_t_GetNbinsZ()_const;">Int_t   GetNbinsZ() const;</h3><p>获取该轴bin数，在三维直方图中使用。</p>
<h3 id="Int_t_GetNcells()_const;">Int_t   GetNcells() const;</h3><p>number of bins(1D), cells (2D) +U/Overflows<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus(),<span class="number">0.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetNcells()&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">20</span>;</span><br><span class="line">TH2D *h =<span class="keyword">new</span> TH2D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">1.0</span>,<span class="number">1.0</span>,bin,-<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus(),r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// int binx,biny;</span></span><br><span class="line"><span class="comment">// h-&gt;GetBinXYZ(h-&gt;GetBin(10,10),binx,biny);</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"binx:"&lt;&lt;binx&lt;&lt;"  biny:"&lt;&lt;biny&lt;&lt;std::endl;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetNcells()&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetNormFactor()_const;">Double_t   GetNormFactor() const;</h3><p>Normalization factor</p>
<p>如果没有设置将会返回0。<br>这个因子是将直方图面积设为该因子。设置该因子参考 SetNormFactor(Double_t factor=1)。</p>
<h3 id="Double_t_GetRandom()_const;">Double_t   GetRandom() const;</h3><p>return a random number distributed according the histogram bin contents.  This function checks if the bins integral exists. If not, the integral is evaluated, normalized to one. The integral is automatically recomputed if the number of entries is not the same then when the integral was computed. NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise. If the histogram has a bin with negative content a NaN is returned<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetRandom()&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="void_GetStats(Double_t_*stats)_const;">void   GetStats(Double_t *stats) const;</h3><p>fill the array stats from the contents of this histogram<br>The array stats must be correctly dimensioned in the calling program.<br>stats[0] = sumw<br>stats[1] = sumw2<br>stats[2] = sumwx<br>stats[3] = sumwx2</p>
<p>If no axis-subrange is specified (via TAxis::SetRange), the array stats is simply a copy of the statistics quantities computed at filling time.If a sub-range is specified, the function recomputes these quantities from the bin contents in the current axis range.</p>
<p>Note that the mean value/RMS is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.</p>
<h3 id="Double_t_GetStdDev(Int_t_axis=1)_const;">Double_t   GetStdDev(Int_t axis=1) const;</h3><p>返回 GetRMS(Int_t axis=1)</p>
<h3 id="Double_t_GetStdDevError(Int_t_axis=1)_const;">Double_t   GetStdDevError(Int_t axis=1) const;</h3><p>返回 GetRMSError(Int_t axis=1)</p>
<h3 id="Double_t_GetSumOfWeights()_const;">Double_t   GetSumOfWeights() const;</h3><p>Return the sum of weights excluding under/overflows.<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus(),<span class="number">0.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetSumOfWeights()&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetRMS(Int_t_axis=1)_const;">Double_t   GetRMS(Int_t axis=1) const;</h3><p>For axis = 1,2 or 3 returns the Sigma value of the histogram along X, Y or Z axis. For axis = 11, 12 or 13 returns the error of RMS estimation along X, Y or Z axis for Normal distribution.</p>
<p>Note that the mean value/sigma is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must  call the static function TH1::StatOverflows(kTRUE) before filling  the histogram.</p>
<p>Note that this function returns the Standard Deviation (Sigma) of the distribution (not RMS). The Sigma estimate is computed as Sqrt((1/N)*(Sum(x_i-x_mean)\^2)). The name “RMS” was introduced many years ago (Hbook/PAW times).<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetRMS(<span class="number">1</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_GetRMSError(Int_t_axis=1)_const;">Double_t   GetRMSError(Int_t axis=1) const;</h3><p>Return error of RMS estimation for Normal distribution.</p>
<p>Note that the mean value/RMS is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows.  To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.</p>
<p>Value returned is standard deviation of sample standard deviation.<br>Note that it is an approximated value which is valid only in the case that the original data distribution is Normal. The correct one would require the 4-th momentum value, which cannot be accurately estimated from an histogram since the x-information for all entries is not kept.<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;GetRMSError(<span class="number">1</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="TAxis*_GetXaxis();">TAxis*   GetXaxis();</h3><p>返回指向该坐标轴 TAxis* 的指针，可对该轴进行设置。具体参考TAxis类的使用。</p>
<h3 id="TAxis*_GetYaxis();">TAxis*   GetYaxis();</h3><p>返回指向该坐标轴 TAxis* 的指针，可对该轴进行设置。具体参考TAxis类的使用。</p>
<h3 id="TAxis*_GetZaxis()">TAxis*   GetZaxis()</h3><p>返回指向该坐标轴 TAxis* 的指针，可对该轴进行设置。具体参考TAxis类的使用。</p>
<h3 id="Double_t_Integral(Option_t_*option=””)_const;">Double_t   Integral(Option_t *option=””) const;</h3><p>Return integral of bin contents. Only bins in the bins range are considered. By default the integral is computed as the sum of bin contents in the range.<br>if option “width” is specified, the integral is the sum of the bin contents multiplied by the bin width in x.<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus(),<span class="number">0.3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;Integral()&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;Integral(<span class="number">10</span>,<span class="number">40</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Double_t_Integral(Int_t_binx1,_Int_t_binx2,_Option_t_*option=””)_const;">Double_t   Integral(Int_t binx1, Int_t binx2, Option_t *option=””) const;</h3><p>Return integral of bin contents in range [binx1,binx2]. By default the integral is computed as the sum of bin contents in the range.<br>if option “width” is specified, the integral is the sum of the bin contents multiplied by the bin width in x.</p>
<h3 id="Double_t_Interpolate(Double_t_x);">Double_t Interpolate(Double_t x);</h3><p>Given a point x, approximates the value via linear interpolation based on the two nearest bin centers.<br>获取x的y值。其值为最近两个bin线性插值。<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bin=<span class="number">60</span>;</span><br><span class="line">TH1D *h=<span class="keyword">new</span> TH1D(<span class="string">"h"</span>,<span class="string">"the title"</span>,bin,-<span class="number">3.0</span>,<span class="number">3.0</span>);</span><br><span class="line">TRandom *r =<span class="keyword">new</span> TRandom();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100000</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;Fill(r-&gt;Gaus());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;h-&gt;Interpolate(<span class="number">0.0</span>)&lt;&lt;<span class="built_in">std</span>::endl;</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="Bool_t_IsBinOverflow(Int_t_bin)_const;">Bool_t   IsBinOverflow(Int_t bin) const;</h3><p>Return true if the bin is overflow.</p>
<h3 id="Bool_t_IsBinUnderflow(Int_t_bin)_const;">Bool_t   IsBinUnderflow(Int_t bin) const;</h3><p>Return true if the bin is overflow.</p>
<h3 id="void_LabelsDeflate(Option_t_*axis=”X”);">void     LabelsDeflate(Option_t *axis=”X”);</h3><p> Reduce the number of bins for the axis passed in the option to the number of bins having a label. The method will remove only the extra bins existing after the last “labeled” bin.</p>
<p>Note that if there are “un-labeled” bins present between “labeled” bins they will not be removed.<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Int_t nx = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *people[nx] = &#123;<span class="string">"Jean"</span>,<span class="string">"Pierre"</span>,<span class="string">"Marie"</span>,<span class="string">"Odile"</span>,<span class="string">"Sebastien"</span>,<span class="string">"Fons"</span>,<span class="string">"Rene"</span>,<span class="string">"Nicolas"</span>,<span class="string">"Xavier"</span>,<span class="string">"Greg"</span>,<span class="string">"Bjarne"</span>,<span class="string">"Anton"</span>,<span class="string">"Otto"</span>,<span class="string">"Eddy"</span>,<span class="string">"Peter"</span>,<span class="string">"Pasha"</span>,<span class="string">"Philippe"</span>,<span class="string">"Suzanne"</span>,<span class="string">"Jeff"</span>,<span class="string">"Valery"</span>&#125;;</span><br><span class="line">TCanvas *c1 = <span class="keyword">new</span> TCanvas(<span class="string">"c1"</span>,<span class="string">"demo bin labels"</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">900</span>,<span class="number">500</span>);</span><br><span class="line">TH1F *h = <span class="keyword">new</span> TH1F(<span class="string">"h"</span>,<span class="string">"test"</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Int_t i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">   Int_t r = gRandom-&gt;Rndm()*<span class="number">20</span>;</span><br><span class="line">   h-&gt;Fill(people[r],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;LabelsDeflate(<span class="string">"X"</span>);</span><br><span class="line">h-&gt;Draw();</span><br></pre></td></tr></table></figure></p>
<h3 id="void_LabelsInflate(Option_t_*axis=”X”);">void     LabelsInflate(Option_t *axis=”X”);</h3><p>Double the number of bins for axis.Refill histogram. This function is called by TAxis::FindBin(const char *label).</p>
<h3 id="oid_LabelsOption(Option_t_*option=”h”,_Option_t_*axis=”X”);">oid     LabelsOption(Option_t *option=”h”, Option_t *axis=”X”);</h3><p>Set option(s) to draw axis with labels</p>
<p>option = “a” sort by alphabetic order<br>\hspace<em>{1.75cm}= “&gt;” sort by decreasing values<br>\hspace</em>{1.75cm}= “&lt;” sort by increasing values<br>\hspace<em>{1.75cm}= “h” draw labels horizontal<br>\hspace</em>{1.75cm}= “v” draw labels vertical<br>\hspace<em>{1.75cm}= “u” draw labels up (end of label right adjusted)<br>\hspace</em>{1.75cm}= “d” draw labels down (start of label left adjusted)<br><figure class="highlight cpp"><figcaption><span>lang: C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Int_t nx = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> Int_t ny = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *month[nx]  = &#123;<span class="string">"January"</span>,<span class="string">"February"</span>,<span class="string">"March"</span>,<span class="string">"April"</span>,<span class="string">"May"</span>,<span class="string">"June"</span>,<span class="string">"July"</span>,<span class="string">"August"</span>,<span class="string">"September"</span>,<span class="string">"October"</span>,<span class="string">"November"</span>,<span class="string">"December"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *people[ny] = &#123;<span class="string">"Jean"</span>,<span class="string">"Pierre"</span>,<span class="string">"Marie"</span>,<span class="string">"Odile"</span>,<span class="string">"Sebastien"</span>,<span class="string">"Fons"</span>,<span class="string">"Rene"</span>,<span class="string">"Nicolas"</span>,<span class="string">"Xavier"</span>,<span class="string">"Greg"</span>,<span class="string">"Bjarne"</span>,<span class="string">"Anton"</span>,<span class="string">"Otto"</span>,<span class="string">"Eddy"</span>,<span class="string">"Peter"</span>,<span class="string">"Pasha"</span>,<span class="string">"Philippe"</span>,<span class="string">"Suzanne"</span>,<span class="string">"Jeff"</span>,<span class="string">"Valery"</span>&#125;;</span><br><span class="line">TCanvas *c1 = <span class="keyword">new</span> TCanvas(<span class="string">"c1"</span>,<span class="string">"demo bin labels"</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">800</span>,<span class="number">800</span>);</span><br><span class="line"><span class="comment">// c1-&gt;SetGrid();</span></span><br><span class="line"><span class="comment">// c1-&gt;SetLeftMargin(0.15);</span></span><br><span class="line"><span class="comment">// c1-&gt;SetBottomMargin(0.15);</span></span><br><span class="line">TH2F *h = <span class="keyword">new</span> TH2F(<span class="string">"h"</span>,<span class="string">"test"</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// h-&gt;SetCanExtend(TH1::kAllAxes);</span></span><br><span class="line"><span class="comment">// h-&gt;SetStats(0);</span></span><br><span class="line">gRandom-&gt;SetSeed();</span><br><span class="line"><span class="keyword">for</span> (Int_t i=<span class="number">0</span>;i&lt;<span class="number">15000</span>;i++) &#123;</span><br><span class="line">   Int_t rx = gRandom-&gt;Rndm()*nx;</span><br><span class="line">   Int_t ry = gRandom-&gt;Rndm()*ny;</span><br><span class="line">   h-&gt;Fill(people[ry],month[rx],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;LabelsDeflate(<span class="string">"X"</span>);</span><br><span class="line">h-&gt;LabelsDeflate(<span class="string">"Y"</span>);</span><br><span class="line">h-&gt;LabelsOption(<span class="string">"v"</span>,<span class="string">"X"</span>);</span><br><span class="line"><span class="comment">// h-&gt;LabelsOption("u","Y");</span></span><br><span class="line">h-&gt;Draw(<span class="string">"text"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="Bool_t_Multiply(TF1_*h1,_Double_t_c1=1);">Bool_t   Multiply(TF1 *h1, Double_t c1=1);</h3><p>Performs the operation: this = this<em>c1</em>f1. if errors are defined (see TH1::Sumw2), errors are also recalculated.</p>
<p>Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply The function return kFALSE if the Multiply operation failed.</p>
<h3 id="Bool_t_Multiply(const_TH1_*h1);">Bool_t   Multiply(const TH1 *h1);</h3><p>Multiply this histogram by h1.  this = this*h1</p>
<p>If errors of this are available (TH1::Sumw2), errors are recalculated.  Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set.</p>
<p>IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed</p>
<h3 id="Bool_t_Multiply(const_TH1_*h1,_const_TH1_*h2,_Double_t_c1=1,_Double_t_c2=1,_Option_t_*option=””);">Bool_t   Multiply(const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option=””);</h3><p>Replace contents of this histogram by multiplication of h1 by h2. this = (c1<em>h1)</em>(c2*h2)</p>
<p>If errors of this are available (TH1::Sumw2), errors are recalculated. Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.</p>
<p>IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed.</p>
<h3 id="void_Paint(Option_t_*option=””);}">void     Paint(Option_t *option=””);}</h3><p>Control routine to paint any kind of histograms.  This function is automatically called by TCanvas::Update.(see TH1::Draw for the list of options)</p>
<h3 id="void_Print(Option_t_*option=””)_const;}">void     Print(Option_t *option=””) const;}</h3><p>Print some global quantities for this histogram.</p>
<p>If option “base” is given, number of bins and ranges are also printed<br>If option “range” is given, bin contents and errors are also printed for all bins in the current range (default 1–&gt;nbins)<br>If option “all” is given, bin contents and errors are also printed for all bins including under and overflows.</p>
<h3 id="TH1_*Rebin(Int_t_ngroup=2,_const_char_*newname=””,_const_Double_t_*xbins=0);">TH1     *Rebin(Int_t ngroup=2, const char *newname=””, const Double_t *xbins=0);</h3><p>Rebin this histogram</p>
<p>-case 1  xbins=0</p>
<p>If newname is blank (default), the current histogram is modified and a pointer to it is returned. If newname is not blank, the current histogram is not modified, and a new histogram is returned which is a Clone of the current histogram with its name set to newname. The parameter ngroup indicates how many bins of this have to be merged into one bin of the result. If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.</p>
<p>examples: if h1 is an existing TH1F histogram with 100 bins<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1-&gt;<span class="constant">Rebin(</span>);  <span class="regexp">//merges</span> two bins <span class="keyword">in</span> one <span class="keyword">in</span> <span class="symbol">h1:</span> previous contents of h1 are lost</span><br><span class="line">h1-&gt;<span class="constant">Rebin(</span><span class="number">5</span>); <span class="regexp">//merges</span> five bins <span class="keyword">in</span> one <span class="keyword">in</span> h1</span><br><span class="line"><span class="constant">TH1F </span>*hnew = h1-&gt;<span class="constant">Rebin(</span><span class="number">5</span>,<span class="string">"hnew"</span>); <span class="regexp">//</span> creates a new histogram hnew merging <span class="number">5</span> bins of h1 <span class="keyword">in</span> one bin</span><br></pre></td></tr></table></figure></p>
<p>NOTE:  If ngroup is not an exact divider of the number of bins, the top limit of the rebinned histogram is reduced to the upper edge of the last bin that can make a complete group. The remaining bins are added to the overflow bin. Statistics will be recomputed from the new bin contents.</p>
<p>-case 2  xbins!=0</p>
<p>A new histogram is created (you should specify newname). The parameter ngroup is the number of variable size bins in the created histogram. The array xbins must contain ngroup+1 elements that represent the low-edges of the bins. If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.</p>
<p>NOTE:  The bin edges specified in xbins should correspond to bin edges in the original histogram. If a bin edge in the new histogram is in the middle of a bin in the original histogram, all entries in the split bin in the original histogram will be transfered to the lower of the two possible bins in the new histogram. This is probably not what you want.</p>
<p>examples: if h1 is an existing TH1F histogram with 100 bins<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Double</span>\_t xbins[<span class="number">25</span>] = <span class="decorator">&#123;...&#125;</span> <span class="type">array</span> <span class="keyword">of</span> low-edges (xbins[<span class="number">25</span>] <span class="keyword">is</span> the upper edge <span class="keyword">of</span> last bin</span><br><span class="line">h1-&gt;<span class="type">Rebin</span>(<span class="number">24</span>,<span class="string">"hnew"</span>,xbins);  //creates a new variable bin size histogram hnew</span><br></pre></td></tr></table></figure></p>
<h3 id="void_Rebuild(Option_t_*option=””);">void     Rebuild(Option_t *option=””);</h3><p>Using the current bin info, recompute the arrays for contents and errors</p>
<h3 id="void_RecursiveRemove(TObject_*obj);">void     RecursiveRemove(TObject *obj);</h3><h3 id="void_Reset(Option_t_*option=””);">void     Reset(Option_t *option=””);</h3><p>Reset this histogram: contents, errors, etc.</p>
<p>if option “ICE” is specified, resets only Integral, Contents and Errors.<br>if option “ICES” is specified, resets only Integral, Contents , Errors and Statistics<br>if option “M”   is specified, resets also Minimum and Maximum<br>The option “ICE” is used when extending the histogram (in ExtendAxis, LabelInflate, etc..)<br>The option “ICES is used in combination with the buffer (see BufferEmpty and BufferFill)  </p>
<h3 id="void_ResetStats();">void     ResetStats();</h3><p>Reset the statistics including the number of entries and replace with values calculates from bin content. The number of entries is set to the total bin content or (in case of weighted histogram) to number of effective entries.</p>
<h3 id="void_Scale(Double_t_c1=1,_Option_t_*option=””);">void     Scale(Double_t c1=1, Option_t *option=””);</h3><p>Multiply this histogram by a constant c1. this = c1*this</p>
<p>Note that both contents and errors(if any) are scaled. This function uses the services of TH1::Add</p>
<p>IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Scale</p>
<p>One can scale an histogram such that the bins integral is equal to the normalization parameter via TH1::Scale(Double_t norm), where norm is the desired normalization divided by the integral of the histogram.</p>
<p>If option contains “width” the bin contents and errors are divided by the bin width.</p>
<h3 id="void_SetAxisColor(Color_t_color=1,_Option_t_*axis=”X”);">void     SetAxisColor(Color_t color=1, Option_t *axis=”X”);</h3><h3 id="void_SetAxisRange(Double_t_xmin,_Double_t_xmax,_Option_t_*axis=”X”);">void     SetAxisRange(Double_t xmin, Double_t xmax, Option_t *axis=”X”);</h3><h3 id="void_SetBarOffset(Float_t_offset=0-25)_{fBarOffset_=_Short_t(1000*offset);}">void     SetBarOffset(Float_t offset=0.25) {fBarOffset = Short_t(1000*offset);}</h3><h3 id="void_SetBarWidth(Float_t_width=0-5)_{fBarWidth_=_Short_t(1000*width);}">void     SetBarWidth(Float_t width=0.5) {fBarWidth = Short_t(1000*width);}</h3><h3 id="void_SetBinContent(Int_t_bin,_Double_t_content);">void     SetBinContent(Int_t bin, Double_t content);</h3><h3 id="void_SetBinContent(Int_t_bin,_Int_t,_Double_t_content);">void     SetBinContent(Int_t bin, Int_t, Double_t content);</h3><h3 id="void_SetBinContent(Int_t_bin,_Int_t,_Int_t,_Double_t_content);">void     SetBinContent(Int_t bin, Int_t, Int_t, Double_t content);</h3><h3 id="void_SetBinError(Int_t_bin,_Double_t_error);">void     SetBinError(Int_t bin, Double_t error);</h3><h3 id="void_SetBinError(Int_t_binx,_Int_t_biny,_Double_t_error);">void     SetBinError(Int_t binx, Int_t biny, Double_t error);</h3><h3 id="void_SetBinError(Int_t_binx,_Int_t_biny,_Int_t_binz,_Double_t_error);">void     SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error);</h3><h3 id="void_SetBins(Int_t_nx,_Double_t_xmin,_Double_t_xmax);">void     SetBins(Int_t nx, Double_t xmin, Double_t xmax);</h3><h3 id="void_SetBins(Int_t_nx,_const_Double_t_*xBins);">void     SetBins(Int_t nx, const Double_t *xBins);</h3><h3 id="void_SetBins(Int_t_nx,_Double_t_xmin,_Double_t_xmax,_Int_t_ny,_Double_t_ymin,_Double_t_ymax);">void     SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax);</h3><h3 id="void_SetBins(Int_t_nx,_const_Double_t_*xBins,_Int_t_ny,_const_Double_t_*yBins);">void     SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins);</h3><h3 id="void_SetBins(Int_t_nx,_Double_t_xmin,_Double_t_xmax,_Int_t_ny,_Double_t_ymin,_Double_t_ymax,_Int_t_nz,_Double_t_zmin,_Double_t_zmax);">void     SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax);</h3><h3 id="void_SetBins(Int_t_nx,_const_Double_t_*xBins,_Int_t_ny,_const_Double_t_*_yBins,_Int_t_nz,_const_Double_t_*zBins);">void     SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t * yBins, Int_t nz, const Double_t *zBins);</h3><h3 id="void_SetBuffer(Int_t_buffersize,_Option_t_*option=””);">void     SetBuffer(Int_t buffersize, Option_t *option=””);</h3><h3 id="void_SetDirectory(TDirectory_*dir);">void     SetDirectory(TDirectory *dir);</h3><h3 id="void_SetLabelColor(Color_t_color=1,_Option_t_*axis=”X”);">void     SetLabelColor(Color_t color=1, Option_t *axis=”X”);</h3><h3 id="void_SetLabelFont(Style_t_font=62,_Option_t_*axis=”X”);">void     SetLabelFont(Style_t font=62, Option_t *axis=”X”);</h3><h3 id="void_SetLabelOffset(Float_t_offset=0-005,_Option_t_*axis=”X”);">void     SetLabelOffset(Float_t offset=0.005, Option_t *axis=”X”);</h3><h3 id="void_SetLabelSize(Float_t_size=0-02,_Option_t_*axis=”X”);">void     SetLabelSize(Float_t size=0.02, Option_t *axis=”X”);</h3><h3 id="void_SetMaximum(Double_t_maximum_=_-1111);">void     SetMaximum(Double_t maximum = -1111);</h3><p>Set the minimum / maximum value for the Y axis (1-D histograms) or Z axis (2-D histograms). By default the maximum / minimum value used in drawing is the maximum / minimum value of the histogram plus a margin of 10\%. If these functions are called, the values are used without any extra margin.</p>
<h3 id="void_SetMinimum(Double_t_minimum_=_-1111);">void     SetMinimum(Double_t minimum = -1111);</h3><h3 id="void_SetName(const_char_*name);">void     SetName(const char *name);</h3><p>Change the name of this histogram</p>
<p>Histograms are named objects in a THashList. We must update the hashlist if we change the name. We protect this operation</p>
<h3 id="void_SetNameTitle(const_char_*name,_const_char_*title);">void     SetNameTitle(const char *name, const char *title);</h3><p>Change the name and title of this histogram</p>
<p>Histograms are named objects in a THashList. We must update the hashlist if we change the name</p>
<h3 id="void_SetNdivisions(Int_t_n=510,_Option_t_*axis=”X”);">void     SetNdivisions(Int_t n=510, Option_t *axis=”X”);</h3><h3 id="void_SetNormFactor(Double_t_factor=1);">void     SetNormFactor(Double_t factor=1);</h3><h3 id="void_SetStats(Bool_t_stats=kTRUE);">void     SetStats(Bool_t stats=kTRUE);</h3><h3 id="void_SetTickLength(Float_t_length=0-02,_Option_t_*axis=”X”);">void     SetTickLength(Float_t length=0.02, Option_t *axis=”X”);</h3><h3 id="void_SetTitleFont(Style_t_font=62,_Option_t_*axis=”X”);">void     SetTitleFont(Style_t font=62, Option_t *axis=”X”);</h3><h3 id="void_SetTitleOffset(Float_t_offset=1,_Option_t_*axis=”X”);">void     SetTitleOffset(Float_t offset=1, Option_t *axis=”X”);</h3><h3 id="void_SetTitleSize(Float_t_size=0-02,_Option_t_*axis=”X”);">void     SetTitleSize(Float_t size=0.02, Option_t *axis=”X”);</h3><h3 id="void_SetTitle(const_char_*title);">void     SetTitle(const char *title);</h3><p>Change (i.e. set) the title</p>
<p>if title is in the form “stringt;stringx;stringy;stringz” the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, and the z axis title to stringz. To insert the character “;” in one of the titles, one should use “#;” or “#semicolon”.</p>
<h3 id="void_SetXTitle(const_char_*title);">void     SetXTitle(const char *title);</h3><h3 id="void_SetYTitle(const_char_*title);">void     SetYTitle(const char *title);</h3><h3 id="void_SetZTitle(const_char_*title);">void     SetZTitle(const char *title);</h3><h3 id="TH1_*ShowBackground(Int_t_niter=20,_Option_t_*option=”same”);">TH1     *ShowBackground(Int_t niter=20, Option_t *option=”same”);</h3><p>This function calculates the background spectrum in this histogram.The background is returned as a histogram.<br>Function parameters:<br>\hspace<em>{0.5cm}-niter, number of iterations (default value = 2). Increasing niter make the result smoother and lower.<br>\hspace</em>{0.5cm}-option: may contain one of the following options<br>\hspace<em>{1.0cm}- to set the direction parameter “BackDecreasingWindow”. By default the direction is BackIncreasingWindow<br>\hspace</em>{1.0cm}- filterOrder-order of clipping filter,  (default “BackOrder2”<br>\hspace<em>{2.0cm}                  -possible values= “BackOrder4”<br>\hspace</em>{5.1cm}                                    “BackOrder6”<br>\hspace<em>{5.1cm}                                    “BackOrder8”<br>\hspace</em>{1.0cm}- “nosmoothing”- if selected, the background is not smoothed. By default the background is smoothed.<br>\hspace<em>{1.0cm}- smoothWindow-width of smoothing window, (default is “BackSmoothing3”)<br>\hspace</em>{2.0cm}                  -possible values= “BackSmoothing5”<br>\hspace<em>{5.1cm}                                    “BackSmoothing7”<br>\hspace</em>{5.1cm}                                    “BackSmoothing9”<br>\hspace<em>{5.1cm}                                    “BackSmoothing11”<br>\hspace</em>{5.1cm}                                    “BackSmoothing13”<br>\hspace<em>{5.1cm}                                    “BackSmoothing15”<br>\hspace</em>{1.0cm}- “nocompton”- if selected the estimation of Compton edge will be not be included   (by default the compton estimation is set)<br>\hspace*{1.0cm}- “same” : if this option is specified, the resulting background histogram is superimposed on the picture in the current pad. This option is given by default.  </p>
<p>NOTE that the background is only evaluated in the current range of this histogram. i.e., if this has a bin range (set via h-&gt;GetXaxis()-&gt;SetRange(binmin, binmax), the returned histogram will be created with the same number of bins as this input histogram, but only bins from binmin to binmax will be filled with the estimated background.</p>
<h3 id="Int_t_ShowPeaks(Double_t_sigma=2,_Option_t_*option=””,_Double_t_threshold=0-05);">Int_t    ShowPeaks(Double_t sigma=2, Option_t *option=””, Double_t threshold=0.05);</h3><p>Interface to TSpectrum::Search.</p>
<p>The function finds peaks in this histogram where the width is &gt; sigma and the peak maximum greater than threshold*maximum bin content of this. For more details see TSpectrum::Search. Note the difference in the default value for option compared to TSpectrum::Search option=”” by default (instead of “goff”).</p>
<h3 id="void_Smooth(Int_t_ntimes=1,_Option_t_*option=””);">void     Smooth(Int_t ntimes=1, Option_t *option=””);</h3><p>Smooth bin contents of this histogram. if option contains “R” smoothing is applied only to the bins defined in the X axis range (default is to smooth all bins). Bin contents are replaced by their smooth values. Errors (if any) are not modified. the smoothing procedure is repeated ntimes (default=1)</p>
<h3 id="void_SmoothArray(Int_t_NN,_Double_t_*XX,_Int_t_ntimes=1);">void     SmoothArray(Int_t NN, Double_t *XX, Int_t ntimes=1);</h3><p>smooth array xx, translation of Hbook routine hsmoof.F<br>based on algorithm 353QH twice presented by J. Friedman in Proc.of the 1974 CERN School of Computing, Norway, 11-24 August, 1974.</p>
<p><strong> 还未发布 </strong></p>
<h2 id=""><br></h2><p>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<strong>Last-Modified: 2015-09-27 23:12</strong></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/08/10/Octopress/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Scientific Linux 下用Octopress免费静态博客系统在Github上搭建个人网站
        
      </div>
    </a>
  
  
    <a href="/2014/12/26/texlive/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Scientific Linux 安装 texlive</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'wuhongyi'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-center">
    		&copy; 2015 Hongyi Wu(吴鸿毅)
    	</div>
      	<!-- <div class="footer-right"> -->
      	<!-- 	<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten -->
      	<!-- </div> -->
    </div>
  </div>
</footer>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>